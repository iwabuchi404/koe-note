# Phase 2.5 実装プラン - UI/UX改善と機能拡張 (承認済み)

## 概要

Phase 3のクリップボード連携前に、ユーザビリティと機能性を大幅に向上させる中間フェーズを実装します。

**決定事項 (2025-07-15承認):**
- UI設計：アコーディオン案を採用
- 準リアルタイム機能：チャンク分割方式を採用
- 複数タスク同時実行：後日検討（ペンディング）

---

## 1. テキスト編集機能

### 1.1 機能概要
文字起こし結果をインライン編集可能にし、セグメント単位での修正を実現します。

### 1.2 実装内容

#### 1.2.1 編集モード切り替え
```typescript
// 編集状態管理
const [editMode, setEditMode] = useState<'view' | 'edit'>('view');
const [editingSegments, setEditingSegments] = useState<Map<number, string>>(new Map());
```

#### 1.2.2 セグメント編集UI
```jsx
// 各セグメントに編集ボタンを追加
<div className="segment-item">
  <div className="segment-timestamp">[00:01:23.4]</div>
  <div className="segment-content">
    {editMode === 'edit' && editingSegments.has(index) ? (
      <textarea 
        value={editingSegments.get(index) || segment.text}
        onChange={(e) => handleSegmentEdit(index, e.target.value)}
        className="segment-editor"
      />
    ) : (
      <span className="segment-text">{segment.text}</span>
    )}
  </div>
  <button onClick={() => toggleSegmentEdit(index)}>
    {editingSegments.has(index) ? '保存' : '編集'}
  </button>
</div>
```

#### 1.2.3 機能詳細
- **編集対象**: セグメント単位のテキスト内容
- **編集方式**: インライン編集（テキストエリア）
- **保存方式**: 個別セグメント保存 + 一括保存オプション
- **変更検知**: 未保存変更のハイライト表示

### 1.3 実装ファイル
- `SpeechRecognition.tsx`: 編集UI追加
- `main.ts`: 編集内容保存API追加
- `preload.ts`: 編集関連IPC追加

---

## 2. UI調整 - アコーディオン方式レイアウト 🎯

### 2.1 採用決定：アコーディオン案

#### 2.1.1 新レイアウト構成
```
┌─────────────────────────────────────────────────────────┐
│ 📝 文字起こし結果 (可変サイズ - メイン) ▼               │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ [編集] [保存] [コピー] [エクスポート]                 │ │
│ │ model: small | 98.5% | 12セグメント                 │ │
│ │ ─────────────────────────────────────────────────── │ │
│ │ [00:00:15.2] こんにちは、今日の会議を始めます           │ │
│ │ [00:00:32.8] プロジェクトの進捗について話しましょう     │ │
│ │ [00:01:05.1] 課題が3つあります...                   │ │
│ │ (拡大可能な表示エリア)                              │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 🎵 音声プレイヤー (固定サイズ) ▼                         │
│ [▶️] [⏸️] [🔊] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
├─────────────────────────────────────────────────────────┤
│ 🎤 音声認識 (固定サイズ) ▼                               │
│ [起動] [停止] [small▼] [🔄実行] 進捗: 処理中...         │
├─────────────────────────────────────────────────────────┤
│ 📹 録音コントロール (固定サイズ) ▼                       │
│ [●録音] [⏸️] [■] デバイス: [マイク▼] 00:01:23          │
└─────────────────────────────────────────────────────────┘
```

#### 2.1.2 アコーディオン実装
```typescript
// アコーディオン状態管理
const [accordionState, setAccordionState] = useState({
  transcription: true,   // 常に展開
  player: false,         // 必要時のみ展開
  recognition: false,    // 必要時のみ展開
  recording: false       // 必要時のみ展開
});

// アコーディオンの高さ計算
const calculateTranscriptionHeight = () => {
  const fixedHeight = Object.entries(accordionState)
    .filter(([key, isOpen]) => key !== 'transcription' && isOpen)
    .reduce((total, [key]) => total + getFixedHeight(key), 0);
  
  return `calc(100vh - ${fixedHeight + 200}px)`;
};
```

### 2.2 実装上の利点
- **ワークフロー効率**: 全機能が一画面で操作可能
- **状況把握**: 録音状態、認識進捗、再生状態を同時確認
- **カスタマイズ性**: ユーザーが必要な機能だけを展開可能
- **メイン機能重視**: 文字起こし結果が最大表示領域を確保

---

## 3. 複数タスク同時実行対応 - ペンディング ⏸️

### 3.1 実装延期の決定
- **理由**: 基本UI構造確立後に検討
- **対応予定**: Phase 2.5完了後に改めて仕様検討
- **現状**: シングルタスク処理を継続

### 3.2 将来実装時の検討事項
- タスク管理システムの設計
- UI表示方式（タブ vs 一覧）
- 並列実行数の制限
- リソース管理とパフォーマンス最適化

---

## 4. UI整理 - アコーディオン方式による解決 ✅

### 4.1 アコーディオン方式の採用効果
- **煩雑さ解消**: 必要な機能のみ表示
- **情報優先度**: 文字起こし結果を最優先表示
- **機能関連性**: 論理的な順序で配置
- **操作効率**: 一画面で全機能にアクセス可能

### 4.2 機能グルーピング（上から下へ）

#### 4.2.1 文字起こし結果 (最優先)
- メイン表示エリア
- 編集・保存・エクスポート機能
- 可変サイズ（他セクション折りたたみ時に拡大）

#### 4.2.2 音声プレイヤー
- 再生コントロール
- 進捗表示
- 音量調整

#### 4.2.3 音声認識
- サーバー起動・停止
- モデル選択
- 認識実行・進捗表示

#### 4.2.4 録音コントロール
- 録音開始・停止・一時停止
- デバイス選択
- 録音時間表示

---

## 5. 準リアルタイム文字起こし機能 🎯

### 5.1 採用決定：チャンク分割方式

#### 5.1.1 技術方式の選択理由
- **実装難易度**: 既存コードの拡張で実現可能
- **安定性**: エラー時の影響範囲が限定
- **音声ファイル統合**: 最終的に1つのファイルとして保存可能

### 5.2 実装仕様

#### 5.2.1 チャンク分割 + 音声ファイル統合
```typescript
class RealtimeTranscriber {
  private chunkSize = 10000; // 10秒チャンク
  private audioChunks: Blob[] = [];  // 最終ファイル用の蓄積
  private finalAudioFile: Blob | null = null;
  
  // 録音中：チャンクを蓄積しながら即座に文字起こし
  addChunk(chunk: Blob) {
    this.audioChunks.push(chunk);           // 最終ファイル用に蓄積
    this.processChunk(chunk);               // 即座に文字起こし
  }
  
  // 録音終了：最終的に1つのファイルを生成
  finalizeRecording(): Blob {
    this.finalAudioFile = new Blob(this.audioChunks, { type: 'audio/webm' });
    return this.finalAudioFile;
  }
}
```

#### 5.2.2 処理フロー
```
録音開始
  ↓
10秒チャンク生成 → 文字起こし処理 → 部分結果表示
  ↓                    ↓
蓄積継続              結果蓄積
  ↓                    ↓
録音終了 → 最終ファイル生成 → 統合結果生成
```

#### 5.2.3 リアルタイム表示UI
```jsx
// 準リアルタイム結果表示
<div className="realtime-transcription">
  <div className="partial-results">
    {partialResults.map(result => (
      <div key={result.id} className="partial-segment">
        <span className="timestamp">[{formatTime(result.timestamp)}]</span>
        <span className="text">{result.text}</span>
        <span className="processing-indicator">🔄</span>
      </div>
    ))}
  </div>
  <div className="current-processing">
    <span>🔄 処理中: チャンク {currentChunkIndex}</span>
  </div>
</div>
```

### 5.3 実装上の利点
- **既存コード活用**: 現在の文字起こしエンジンをそのまま使用
- **エラー処理**: チャンク単位でのリトライ処理
- **メモリ効率**: 処理済みチャンクの適切な解放
- **ファイル管理**: 従来と同じファイル管理システム

---

## 実装優先順位 (承認済み)

### Phase 2.5.1 (Week 1) - UI基盤構築
1. **アコーディオンUI実装** ✅ 承認済み
   - 4つのセクション（文字起こし結果、プレイヤー、認識、録音）
   - 展開/折りたたみ機能
   - 文字起こし結果エリアの可変サイズ対応

### Phase 2.5.2 (Week 2) - 編集機能
2. **テキスト編集機能** ✅ 承認済み
   - セグメント単位のインライン編集
   - 保存・復元機能
   - 未保存変更のハイライト

### Phase 2.5.3 (Week 3-4) - 高度機能
3. **準リアルタイム文字起こし** ✅ 承認済み
   - チャンク分割方式
   - 音声ファイル統合
   - リアルタイム表示UI

### ペンディング項目
- **複数タスク同時実行**: Phase 2.5完了後に検討

---

## 承認済み決定事項 ✅

### 1. UI構造 - アコーディオン方式採用
- ✅ **承認済み**: 縦分割レイアウトからアコーディオン構造への変更
- ✅ **承認済み**: 文字起こし結果をメイン表示、他機能は折りたたみ可能

### 2. 機能実装の優先順位
- ✅ **承認済み**: 提案した3段階の実装順序
- ✅ **承認済み**: テキスト編集機能の実装

### 3. 技術的制約
- ✅ **承認済み**: 準リアルタイム機能 - チャンク分割方式
- ✅ **承認済み**: 音声ファイル統合による1つのファイル保存

### 4. ユーザー体験
- ✅ **承認済み**: アコーディオン方式によるワークフロー重視設計
- ⏸️ **ペンディング**: 複数タスク同時実行は後日検討

---

**実装開始準備完了 - Phase 2.5.1 (アコーディオンUI実装) から開始します。**